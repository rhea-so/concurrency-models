함수형 프로그래밍은 진보적이고 미래적이다. 아직은 대중적으로 사용되고 있지는 않지만 향 후 20년을 책임질 수소 연료 자동차를 운전하는 것과 비슷하다.

실행될 때마다 어떤 공통의 상태를 변경하는 일련의 명령문으로 이루어진 명령형 프로그램과 달리 함수형 프로그래밍 모델은 표현을 평가하는 방식으로 계산을 수행한다.  
그런 표현은 (일반적인 값과 똑같이 취급되는) 1급 개체면서 부작용이 없는 순수 수학적 함수에서 만들어진다.  

함수는 부작용에서 자유롭기 때문에 스레드의 안정성과 관련해서 사고하는 것을 훨씬 단순하게 만들어줌으로써 동시성에 특별한 강점을 갖는다.  

그리고 이것은 우리가 살펴보는 모델 중에서 병렬성이 직접 구현되도록 만들어주는 첫 번째 모델에 해당한다.

## 문제가 있으면 멈추는 것이 상책이다!

2장 "스레드와 잠금장치"에서 잠그기와 관련해서 논의한 규칙은, 여러 개의 스레드에 의해서 공유되고 값이 변경되는 데이터에 한해서 적용된다.  
즉, 가변이면서 공유되는 상태에만 적용되는 것이다. 이에 비해서 값이 변하지 않는 (즉 불변인) 데이터는 잠금장치가 없어도 여러 개의 스레드가 안전하게 접근할 수 있다.

함수형 프로그래밍이 동시성이나 병렬성과 관련해서 매력을 갖는 이유가 여기에 있다. 함수형 프로그램은 가변인 상태가 아예 없으므로, 가변이면서 공유되는 상태에서 야기되는 문제와 원천적으로 아무 상관이 없다.

이 장에서 우리는 JVM에서 동작하는 LISP의 변종인 클로저가 구현한 함수형 프로그램을 살펴 볼 것이다.  

> [LISP란? 1958년에 개발된 함수형 언어](https://ko.m.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84)

클로저는 동적 타이핑을 사용한다. 루비나 파이썬에 익숙한 사람이라면 일단 클로저의 낯선 문법만 어느 정도 익히면 전체적인 개념이 편하게 느껴질 것이다.  

클로저가 순수 함수형 언어는 아니지만, 이 장에서는 그것이 담고 있는 순수 함수의 측면을 집중적으로 만나게 될 것이다.  
이 장의 내용을 공부하기 위해서 클로저를 간략하게 설명하겠지만, 자세한 내용을 공부하고 싶은 사람은 스튜어트 할로웨이와 아론 베드라가 쓴 "프로그래밍 클로저"를 읽어보기 바란다.

1일 차에는 함수형 프로그래밍의 몇 가지 기초를 보고 함수 알고리즘을 병렬화하는 것이 얼마나 쉬운지 볼 것이다.  
2일 차에는 클로저가 사용하는 축소자 프레임워크를 자세히 살펴보고, 이 병렬장치가 내부적으로 어떻게 동작하는지 알아본다.  
끝으로 3일 차에는 병렬성에서 동시성으로 초점을 옮겨서 퓨처와 프라미스를 이용한 동시적 웹 서비스를 만들어본다.

## 1일 차: 가변 상태 없이 프로그래밍 하기

함수형 프로그래밍을 처음 접하면 대부분의 프로그래머들이 믿지 못하겠다는 표정을 짓는다.  
변수의 값을 바꾸지 않으면서 제대로 된 프로그램을 작성하는 것이 가능하지 않다고 생각하기 때문이다.  

그러나 그게 가능할 뿐만 아니라, 보통의 명령형 코드와 비교했을 때 더 간단하고 쉽다는 사실을 곧 확인하게 될 것이다.

### 가변 상태의 위험

여기서는 일단 병렬성에 초점을 맞춘다. 간단한 함수 프로그램을 작성한 다음, 그것이 함수 패러다임을 쓰기 때문에 병렬성에 대한 지원이 매우 쉽다는 점을 보여줄 것이다.  
우선 Java로 작성한 한두 개의 예를 통해서 가변 상태를 피하는 것이 왜 도움이 되는지 확인해보자.

> 가변 상태란? 임의의 복잡한 상태에 놓일 수 있는 상황이다.

> ... 스레드 안정성이 보장되지 않는 매우 단순한 코드

겉에서 보이지 않거나 이런 식으로 탈출한 상태는 동시성 프로그램에서 가변 상태가 가질 수 있는 대표적인 두 가지 위험에 속한다.  
다른 위험도 많이 존재하는데, 이런 위험은 우리가 가변 상태를 완전히 피해야 사라진다.  
함수형 프로그래밍이 제공하는 방법이 정확히 그것이다.

### 클로저에 대한 초스피드 안내

> 클로저란 함수가 Lexical 환경(environment)의 변수를 참조하는 것을 말한다.  
> Lexical이 무엇인지는 LISP에서 Lexical(어휘적)과 Dynamic(동적) 변수 타입를 참고하라.  
> 다른 언어들에서 사용하는 Local, Global 정도의 차이로 생각하면 된다.

클로저가 사용하는 리스프 문법을 살펴보는 것은 몇 분 정도면 충분하다.

클로저를 읽히는 가장 좋은 방법은 lein repl (lein은 클로저의 표준 빌드 도구다)이라는 명령을 통해서 호출할 수 있는 REPL(read-evaluate-print-loop)을 사용하는 것이다.  
이것을 사용하면 소스 파일을 만들고 컴파일하는 과정이 없어도 코드를 입력해 바로 결과를 확인할 수 있다. 익숙하지 않은 코드를 실험적으로 사용할때 탁월한 도움을 주는 방법이다.  
REPL을 시작하면 다음과 같은 프롬프트가 나타난다.

```LISP
user=>
```

여기에 클로저 코드를 입력하면 바로 평가된다.

클로저 코드는 대부분 s- 표현이라고 불리는, 괄호로 표기되는 리스트로 구성된다. 대부분의 언어가 max(3, 5)라고 작성하는 함수 호출이 클로저에서는 다음과 같이 작성된다.

```LISP
user=> (max 3 5)
5
```

수학적 연산도 마찬가지다. 예를 들어 1+2*3은 다음과 같다.

```LISP
user=> (+ 1 (3 * 3))
7
```

상수를 선언하는 것은 def를 이용한다.

```LISP
user=> (def meaning-of-life 42)
#'user/meaning-of-life
user=> meaning-of-life
42
```

제어 구조마저 s- 표현을 사용한다.

```LISP
user=> (if (< meaning-of-life 0) "negative" "non-negative")
"non-negative"
```

클로저에서는 거의 대부분이 s- 표현이지만, 예외도 존재한다. 백터(배열) 리터럴은 대괄호로 표현된다.

```LISP
user=> (def droids ["Huey" "Dewey" "Louie"])
#'user/droids
user=> (count droids)
3
user=> (droids 0)
"Huey"
user=> (droids 2)
"Louie"
```

맵 리터럴은 중괄호로 표현된다.

```LISP
user=> (def me {:name "Paul" :age 45 :sex :male})
#'user/me
user=> (:age me)
45
```

맵에 담긴 키는 종종 콜론으로 시작되는, Ruby의 심볼이나 Java에서 인턴 처리된 문자열과 매우 흡사한 구조물을 지칭하는 키워드를 사용한다. 

끝으로, 함수는 defn으로 정의하고, 인수는 벡터로 표현된다.

```LISP
user=> (defn percentage [x p] (* x (/ p 100.0)))
#'user/percentage
user=> (percentage 200 10)
20.0
```

클로저에 대한 소개는 이렇게 마무리하고, 언어의 다른 측면에 대해서는 필요할 때마다 따로 설명할 것이다.

### 첫 함수 프로그램

함수형 프로그래밍이 가지고 있는 가장 흥미로운 요소는 그것이 가변 상태를 원천적으로 피하는 것이라고 앞서 말했다.  
하지만 그와 관련된 예는 아직 본 적이 없다. 이제 예를 살펴보자.

일련의 수가 있다고 하고, 그들을 서로 더한 값을 계산해보자. Java와 같은 명령형 언어에서라면 아마 다음과 같이 코드를 작성할 것이다.  

```typescript
function sum(numbers: number[]): number {
  let accumulator: number = 0;
  for (const number of numbers) {
    accumulator += number;
  }
  return accumulator;
}
```

accumulator의 상태가 변경되고 있기 때문에 이것은 함수적이지 않다. 그것은 루프가 돌 때마다 값이 달라진다. 다음 클로저 코드는 가변 변수를 사용하지 않는다.

```LISP
(defn recursive-sum [numbers])
  (if (empty? numbers)
    0
    (+ (first numbers) (recursive-sum (rest numbers))))
```

> rest는 배열에서 0번 위치에 있는 Element를 제거하는 함수  
> first는 배열에서 0번 위치에 있는 Element의 값을 읽어오는 함수

이것은 재귀적 해법이다. recursive-sum은 (재귀적으로) 스스로를 호출한다. numbers 벡터가 비었으면 단순히 0을 리턴한다. 그렇지 않으면 numbers의 첫 번째 요소(머리)의 값을 나머지 요소들(꼬리)의 총합에 더한다.  

이러한 재귀적 해법이 정확한 답을 찾아주긴 하지만, 더 나은 해법이 있다. 다음은 좀 더 간단하고 효과적인 해법이다.  

```LISP
(defn reduce-sum [numbers]
  (reduce (fn [acc x] (+ acc x)) 0 numbers))
```

이것은 클로저의 reduce 함수를 이용한다. 이 함수는 내부에서 실행할 함수, 초깃값, 그리고 컬렉션이라는 세 개의 인수를 받아들인다.

이 코드는 fn이라는 키워드를 이용해 두 개의 인수를 받아서 합을 리턴하는 함수를 정의한다.  
이 함수는 컬렉션에 담긴 각 요소를 대상으로 한 번씩 호출된다. 처음 호출될 때는 (이 예제에서는 0인) 초깃값과 컬렉션의 첫 번째 요소가 인수로 전달된다.  
두 번째 호출될 때는 첫 번쨰 호출 결과와 컬렉션의 두 번째 요소가 인수로 전달된다. 이런 과정이 계속 반복된다.

아직 끝난 것이 아니다. 우리는 두 개의 인수를 받아서 둘을 합한 결과를 리턴하는 함수로 +를 사용한다는 점에 주목할 필요가 있다.  
익명의 함수를 만들 필요조차 없이 아예 +를 인수로 전달하면 더 좋은 코드를 작성할 수 있다.

```LISP
(defn sum [numbers]
  (reduce + numbers))
```

이제 명령형 코드에 비해서 간단하고 간결한 코드를 작성하였다. 명령형 코드를 함수 코드로 바꿀 때 보통 이와 비슷한 단계를 밟아나간다는 사실을 알게 될 것이다.

### 어렵지 않게 만들 수 있는 병렬성

함수 코드를 작성했으니, 이제 병렬성에 대해서 생각해볼 순서다. sum 함수를 병렬적으로 만들기 위해서 필요한 일이 무엇일까? 거의 없다.

```LISP
(ns sum.core
  (:require [clojure.core.reducers :as r]))

(defn parallel-sum [numbers]
  (r/fold + numbers))
```

이 코드를 앞 버전과 비교했을 때 다른 점은 reduce를 사용하는 대신 (타이핑을 줄이기 위해서 보통 r이라고 줄여 쓰는) clojure.core.reducers 패키지에 있는 함수를 사용하고 있다는 점이다.

다음은 이렇게 하는 것이 성능 측면에서 어떤 도움을 주는지 보여주기 위한 REPL 세션이다.

```LISP
sum.core=> (def numbers (into [] (range 0 10000000)))
#'sum.core/numbers
sum.core=> (time (sum numbers))
"Elapsed time: 1128.420209 msecs"
49999995000000
sum.core=> (time (parallel-sum numbers))
"Elapsed time: 236.031693 msecs"
49999995000000
```

intro를 이용해 (range 0 10000000) 의 결과를 빈 벡터에 넣음으로써 0에서 천만 사이에 이르는 모든 정수를 담고 있는 벡터를 만든다.  
그 다음에 코드가 실행되는 시간을 출력하는 time 매크로를 이용한다. JVM에서 실행되는 코드가 대개 그렇듯이 저스트-인-타임 컴파일러가 개입해서 최적화된 속도를 만들어낼 수 있도록 똑같은 코드를 여러번 실행해야 한다.

> 내 iPad에서 테스트 해봤을때는 아무런 변화가 없었다.. 코어를 하나만 쓰는지 parallel는 오히려 더 느렸다..  
> 내 iPad로 더 병렬성 속도 테스트를 진행하는게 의미가 있을까.. 맥미니를 꺼내야하나..

### 함수 방식으로 단어 세기

이제 순차적인 방식으로 단어 세는 코드를 작성하고, 2일 차에선 그 코드를 병렬화할 것이다.  
그렇게 하기 위해서는 다음과 같은 세 가지가 필요하다.

* 위키피디아 XML 데이터가 주어졌다고 했을 때, 그 안에 담긴 페이지를 순차적으로 리턴하는 함수
* 페이지가 주어졌다고 했을 때, 그 안에 담긴 단어를 순차적으로 리턴하는 함수
* 일련의 단어가 주어졌다고 했을 때, 각 단어와 해당 단어의 빈도를 담은 맵을 리턴하는 함수

이 중에서 처음 두 개 함수에 대해서는 자세하게 다루지 않을 것이다. 이 책은 동시성에 대한 책이지 XML 해석에 관한 책이 아니기 때문이다.  
하지만 단어를 실제로 세는 함수에 대해서는 자세히 살펴볼 것이다. 그 함수가 우리가 나중에 병렬화 할 대상이다.

### 함수적인 맵

단어의 빈도를 담은 맵을 리턴할 것이기 때문에, 클로저의 맵 함수인 get과 assoc을 알아둘 필요가 있다.

```LISP
user=> (def counts {"apple" 2 "orange" 1})
#'user/counts
user=> (get counts "apple" 0)
2
user=> (get counts "banana" 0)
0
user=> (assoc counts "banana" 1)
{"banana" 1, "orange" 1, "apple" 2}
user=> (assoc counts "apple" 3)
{"orange" 1, "apple" 3}
```

get은 주어진 키에 해당하는 내용을 맵에서 찾아본 후 해당하는 값이 있으면 그것을 리턴하고, 값이 없으면 기본 값을 리턴한다. assoc은 맵, 키, 그리고 값을 인수로 받은 다음 해당 키와 값이 포함된 맵을 새로 리턴한다.

### 빈도

이제 일련의 단어를 인수로 받아들이고 단어와 빈도를 담고 있는 맵을 리턴하는 함수를 작성할 준비가 되었다.

```LISP
(defn word-frequencies [words]
  (reduce
    (fn [counts word] (assoc counts word (inc (get counts word 0))))
    {} words))
```

reduce에 초깃값으로 빈 맵 {}을 전달하고 있다. 그 다음에 words에 담긴 각 단어에 대해서 해당 단어의 빈도에 1을 더한다. 이 함수가 실제로 사용되는 예는 다음과 같다.

```LISP
user=> (word-frequencies ["one" "potato" "two" "potato" "three" "potato" "four"])
{"one" 1, "potato" 3, "two" 1, "three" 1, "four" 1}
```

> (word-frequencies ["one", "potato", "two", "potato", "three", "potato", "four"])로 ,를 붙혀서 실행해도 아무 문제없이 동작한다.

사실 클로저의 표준 라이브러리는 우리보다 한 발 빨랐다. 컬렉션을 받아들여서 그 안에 담긴 멤버들의 빈도를 담은 맵을 리턴하는 frequencies라는 이름의 표준 함수가 이미 존재한다.

```LISP
user=> (frequencies ["one" "potato" "two" "potato" "three" "potato" "four"])
{"one" 1, "potato" 3, "two" 1, "three" 1, "four" 1}
```

이제 단어를 셀 수 있게 되었으므로, XML 처리와 관련된 일만 남았다.

### 열과 관련된 추가적인 함수들

XML을 처리하기 전에, 약간의 메커니즘을 소개할 필요가 있다. 먼저 map 함수다.

```LISP
user=> (map inc [0 1 2 3 4 5])
(1 2 3 4 5 6)
(map (fn [x] (* 2 x)) [0 1 2 3 4 5])
(0 2 4 6 8 10)
```

map은 함수와 열이 주어지면 열에 담긴 각 요소에 함수를 적용한 결과를 담는 새로운 열을 리턴한다.  
하나의 함수, 그리고 둘 이상의 인수를 받아들여서 부분적용 함수를 리턴하는 partial을 이용하면 두 번째 버전을 조금 더 단순하게 만들 수 있다.

```LISP
user=> (def multiply-by-2 (partial * 2))
#'user/multiply-by-2
user=> (multiply-by-2 3)
6
user=> (map (partial * 2) [0 1 2 3 4 5])
(0 2 4 6 8 10)
```

이제 정규표현을 이용해서 문자열을 여러 개의 단어로 나누는 것과 같이 어떤 열을 리턴하는 함수가 있다고 하자.

```LISP
user=> (defn get-words [text] (re-seq #"\w+" text))
#'user/get-words
user=> (get-words "one two three four")
("one" "two" "three" "four")
```

이 함수를 문자열로 이루어진 열에 매핑하면 열을 원소로 갖는 열을 얻게 된다.

```LISP
user=> (map get-words ["one two three" "four five six" "seven eight nine"])
(("one" "two" "three") ("four" "five" "six") ("seven" "eight" "nine"))
```

모든 열의 원소들이 해체되어 하나로 연결된 열을 갖고 싶으면 mapcat을 사용하면 된다.

```LISP
user=> (mapcat get-words ["one two three" "four five six" "seven eight nine"])
("one" "two" "three" "four" "five" "six" "seven" "eight" "nine")
```

이제 단어 세기 함수를 만들기 위해서 필요한 도구를 모두 갖추었다.

> ... 각 페이지에 담긴 단어들의 빈도를 담은 맵을 리턴하는 등의 함수들은 생략.. 양이 너무 많습니다.



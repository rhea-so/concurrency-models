함수형 프로그래밍은 진보적이고 미래적이다. 아직은 대중적으로 사용되고 있지는 않지만 향 후 20년을 책임질 수소 연료 자동차를 운전하는 것과 비슷하다.

실행될 때마다 어떤 공통의 상태를 변경하는 일련의 명령문으로 이루어진 명령형 프로그램과 달리 함수형 프로그래밍 모델은 표현을 평가하는 방식으로 계산을 수행한다.  
그런 표현은 (일반적인 값과 똑같이 취급되는) 1급 개체면서 부작용이 없는 순수 수학적 함수에서 만들어진다.  

함수는 부작용에서 자유롭기 때문에 스레드의 안정성과 관련해서 사고하는 것을 훨씬 단순하게 만들어줌으로써 동시성에 특별한 강점을 갖는다.  

그리고 이것은 우리가 살펴보는 모델 중에서 병렬성이 직접 구현되도록 만들어주는 첫 번째 모델에 해당한다.

## 문제가 있으면 멈추는 것이 상책이다!

2장 "스레드와 잠금장치"에서 잠그기와 관련해서 논의한 규칙은, 여러 개의 스레드에 의해서 공유되고 값이 변경되는 데이터에 한해서 적용된다.  
즉, 가변이면서 공유되는 상태에만 적용되는 것이다. 이에 비해서 값이 변하지 않는 (즉 불변인) 데이터는 잠금장치가 없어도 여러 개의 스레드가 안전하게 접근할 수 있다.

함수형 프로그래밍이 동시성이나 병렬성과 관련해서 매력을 갖는 이유가 여기에 있다. 함수형 프로그램은 가변인 상태가 아예 없으므로, 가변이면서 공유되는 상태에서 야기되는 문제와 원천적으로 아무 상관이 없다.

이 장에서 우리는 JVM에서 동작하는 LISP의 변종인 클로저가 구현한 함수형 프로그램을 살펴 볼 것이다.  

> [LISP란? 1958년에 개발된 함수형 언어](https://ko.m.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%ED%94%84)

클로저는 동적 타이핑을 사용한다. 루비나 파이썬에 익숙한 사람이라면 일단 클로저의 낯선 문법만 어느 정도 익히면 전체적인 개념이 편하게 느껴질 것이다.  

클로저가 순수 함수형 언어는 아니지만, 이 장에서는 그것이 담고 있는 순수 함수의 측면을 집중적으로 만나게 될 것이다.  
이 장의 내용을 공부하기 위해서 클로저를 간략하게 설명하겠지만, 자세한 내용을 공부하고 싶은 사람은 스튜어트 할로웨이와 아론 베드라가 쓴 "프로그래밍 클로저"를 읽어보기 바란다.

1일 차에는 함수형 프로그래밍의 몇 가지 기초를 보고 함수 알고리즘을 병렬화하는 것이 얼마나 쉬운지 볼 것이다.  
2일 차에는 클로저가 사용하는 축소자 프레임워크를 자세히 살펴보고, 이 병렬장치가 내부적으로 어떻게 동작하는지 알아본다.  
끝으로 3일 차에는 병렬성에서 동시성으로 초점을 옮겨서 퓨처와 프라미스를 이용한 동시적 웹 서비스를 만들어본다.

## 1일 차: 가변 상태 없이 프로그래밍 하기

함수형 프로그래밍을 처음 접하면 대부분의 프로그래머들이 믿지 못하겠다는 표정을 짓는다.  
변수의 값을 바꾸지 않으면서 제대로 된 프로그램을 작성하는 것이 가능하지 않다고 생각하기 때문이다.  

그러나 그게 가능할 뿐만 아니라, 보통의 명령형 코드와 비교했을 때 더 간단하고 쉽다는 사실을 곧 확인하게 될 것이다.

### 가변 상태의 위험

여기서는 일단 병렬성에 초점을 맞춘다. 간단한 함수 프로그램을 작성한 다음, 그것이 함수 패러다임을 쓰기 때문에 병렬성에 대한 지원이 매우 쉽다는 점을 보여줄 것이다.  
우선 Java로 작성한 한두 개의 예를 통해서 가변 상태를 피하는 것이 왜 도움이 되는지 확인해보자.

> 가변 상태란? 임의의 복잡한 상태에 놓일 수 있는 상황이다.

> ... 스레드 안정성이 보장되지 않는 매우 단순한 코드

겉에서 보이지 않거나 이런 식으로 탈출한 상태는 동시성 프로그램에서 가변 상태가 가질 수 있는 대표적인 두 가지 위험에 속한다.  
다른 위험도 많이 존재하는데, 이런 위험은 우리가 가변 상태를 완전히 피해야 사라진다.  
함수형 프로그래밍이 제공하는 방법이 정확히 그것이다.

### 클로저에 대한 초스피드 안내

> 클로저란 함수가 Lexical 환경(environment)의 변수를 참조하는 것을 말한다.  
> Lexical이 무엇인지는 LISP에서 Lexical(어휘적)과 Dynamic(동적) 변수 타입를 참고하라.  
> 다른 언어들에서 사용하는 Local, Global 정도의 차이로 생각하면 된다.

클로저가 사용하는 리스프 문법을 살펴보는 것은 몇 분 정도면 충분하다.

클로저를 읽히는 가장 좋은 방법은 lein repl (lein은 클로저의 표준 빌드 도구다)이라는 명령을 통해서 호출할 수 있는 REPL(read-evaluate-print-loop)을 사용하는 것이다.  
이것을 사용하면 소스 파일을 만들고 컴파일하는 과정이 없어도 코드를 입력해 바로 결과를 확인할 수 있다. 익숙하지 않은 코드를 실험적으로 사용할때 탁월한 도움을 주는 방법이다.  
REPL을 시작하면 다음과 같은 프롬프트가 나타난다.

```REPL
user=>
```

여기에 클로저 코드를 입력하면 바로 평가된다.

클로저 코드는 대부분 s- 표현이라고 불리는, 괄호로 표기되는 리스트로 구성된다. 대부분의 언어가 max(3, 5)라고 작성하는 함수 호출이 클로저에서는 다음과 같이 작성된다.

```REPL
user=> (max 3 5)
5
```

수학적 연산도 마찬가지다. 예를 들어 1+2*3은 다음과 같다.

```REPL
user=> (+ 1 (3 * 3))
7
```

상수를 선언하는 것은 def를 이용한다.

```REPL
user=> (def meaning-of-life 42)
#'user/meaning-of-life
user=> meaning-of-life
42
```

제어 구조마저 s- 표현을 사용한다.

```REPL
user=> (if (< meaning-of-life 0) "negative" "non-negative")
"non-negative"
```

클로저에서는 거의 대부분이 s- 표현이지만, 예외도 존재한다. 백터(배열) 리터럴은 대괄호로 표현된다.

```REPL
user=> (def droids ["Huey" "Dewey" "Louie"])
#'user/droids
user=> (count droids)
3
user=> (droids 0)
"Huey"
user=> (droids 2)
"Louie"
```

맵 리터럴은 중괄호로 표현된다.

```REPL
user=> (def me {:name "Paul" :age 45 :sex :male})
#'user/me
user=> (:age me)
45
```

맵에 담긴 키는 종종 콜론으로 시작되는, Ruby의 심볼이나 Java에서 인턴 처리된 문자열과 매우 흡사한 구조물을 지칭하는 키워드를 사용한다. 

끝으로, 함수는 defn으로 정의하고, 인수는 벡터로 표현된다.

```REPL
user=> (defn percentage [x p] (* x (/ p 100.0)))
#'user/percentage
user=> (percentage 200 10)
20.0
```

클로저에 대한 소개는 이렇게 마무리하고, 언어의 다른 측면에 대해서는 필요할 때마다 따로 설명할 것이다.

### 첫 함수 프로그램

함수형 프로그래밍이 가지고 있는 가장 흥미로운 요소는 그것이 가변 상태를 원천적으로 피하는 것이라고 앞서 말했다.  
하지만 그와 관련된 예는 아직 본 적이 없다. 이제 예를 살펴보자.

일련의 수가 있다고 하고, 그들을 서로 더한 값을 계산해보자. Java와 같은 명령형 언어에서라면 아마 다음과 같이 코드를 작성할 것이다.  

```typescript
function sum(numbers: number[]): number {
  let accumulator: number = 0;
  for (const number of numbers) {
    accumulator += number;
  }
  return accumulator;
}
```

accumulator의 상태가 변경되고 있기 때문에 이것은 함수적이지 않다. 그것은 루프가 돌 때마다 값이 달라진다. 다음 클로저 코드는 가변 변수를 사용하지 않는다.

```REPL
(defn recursive-sum [numbers])
  (if (empty? numbers)
    0
    (+ (first numbers) (recursive-sum (rest numbers))))
```

> rest는 배열에서 0번 위치에 있는 Element를 제거하는 함수  
> first는 배열에서 0번 위치에 있는 Element의 값을 읽어오는 함수

이것은 재귀적 해법이다. recursive-sum은 (재귀적으로) 스스로를 호출한다. numbers 벡터가 비었으면 단순히 0을 리턴한다. 그렇지 않으면 numbers의 첫 번째 요소(머리)의 값을 나머지 요소들(꼬리)의 총합에 더한다.  

이러한 재귀적 해법이 정확한 답을 찾아주긴 하지만, 더 나은 해법이 있다. 다음은 좀 더 간단하고 효과적인 해법이다.  

```REPL
(defn reduce-sum [numbers]
  (reduce (fn [acc x] (+ acc x)) 0 numbers))
```

이것은 클로저의 reduce 함수를 이용한다. 이 함수는 내부에서 실행할 함수, 초깃값, 그리고 컬렉션이라는 세 개의 인수를 받아들인다.

이 코드는 fn이라는 키워드를 이용해 두 개의 인수를 받아서 합을 리턴하는 함수를 정의한다.  
이 함수는 컬렉션에 담긴 각 요소를 대상으로 한 번씩 호출된다. 처음 호출될 때는 (이 예제에서는 0인) 초깃값과 컬렉션의 첫 번째 요소가 인수로 전달된다.  
두 번째 호출될 때는 첫 번쨰 호출 결과와 컬렉션의 두 번째 요소가 인수로 전달된다. 이런 과정이 계속 반복된다.

아직 끝난 것이 아니다. 우리는 두 개의 인수를 받아서 둘을 합한 결과를 리턴하는 함수로 +를 사용한다는 점에 주목할 필요가 있다.  
익명의 함수를 만들 필요조차 없이 아예 +를 인수로 전달하면 더 좋은 코드를 작성할 수 있다.

```REPL
(defn sum [numbers]
  (reduce + numbers))
```

이제 명령형 코드에 비해서 간단하고 간결한 코드를 작성하였다. 명령형 코드를 함수 코드로 바꿀 때 보통 이와 비슷한 단계를 밟아나간다는 사실을 알게 될 것이다.
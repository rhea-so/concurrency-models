# 서문

최근 들어서 우리는 하나의 CPU 속도가 빨라지는 것이 아니라 컴퓨터에 들어가는 코어의 개수가 늘어나는 것을 알게 되었다.

허브 서터가 말한 것 처럼 "공짜 점심은 끝났다". 단순히 더 빠른 하드웨어가 출시되기를 기다리기만 하면 소프트웨어의 속도를 향상시킬 수 있던 시대는 지나갔다. 이제는 여러 개의 코어, 즉 병렬성을 활용해야 하는 것이다.

## 동시성 혹은 병렬성?

이 두 개념은 종종 비슷한 의미로 사용되지만, `동시적`이라는 말과 `병렬적`이라는 말은 서로 다른 개념이다.

`동시적` 프로그램은 여러 개의 논리적 `통제 흐름`을 갖는다. 이러한 논리적 흐름, 즉 스레드는 병렬로 실행될 수도 있고 그렇지 않을 수도 있다.

이에 비해서 `병렬적` 프로그램은 계산에 필요한 부분을 한꺼번에 (병렬로) 실행함으로써 순차적 프로그램보다 빨리 동작할 가능성이 있다. 프로그램에서 사용하는 논리적 통제 흐름은 하나가 될 수도 있고 그 이상일 수도 있다.

이러한 차이를 이해하는 또 다른 방식은 동시성이라는 문제 자체가 가진 속성에 있다고 생각한다는 점이다.

동시성 프로그램은 여러 사건을 한꺼번에 (혹은 거의 한꺼번에) 처리해야 하는 요구사항을 갖는다. 이에 비해서 병렬성은 문제가 아닌 해법이 가진 속성이므로, 프로그램 내의 각기 다른 부분을 병렬로 실행함으로써 해법 자체의 처리 속도를 더 빠르게 한다.

롭 파이크는 이렇게 말했다.

> 동시성은 여러 일을 한꺼번에 다루는 데 관한 것이다.  

> 병렬성은 여러 일을 한꺼번에 실행하는 데 관한 것이다.

그렇다면 이 책은 동시성에 대한 책인가, 아니면 병렬성에 대한 책인가?

### 예시

내 아내는 교사다. 다른 교사들과 마찬가지로 그녀는 멀티태스킹에 능숙하다.  
어느 한 시점에서 보면 그녀는 한 가지 일을 수행하지만, 언제나 여러 일을 한꺼번에 다루어야 한다.  
한 학생이 책을 읽는 것을 듣는 동시에, 떠들석한 교실을 진정시키거나 다른 학생의 질문에 답을 주는 식이다.  
이것이 동시성이지 병렬성은 아니다. 즉, 내 아내는 한 명 뿐이다.

그녀를 돕는 조교가 같이 있다면 (한 사람이 책 읽는 걸 듣고 지도하는 동안, 다른 사람은 질문에 답하는 식으로) 동시성과 병렬성이 모두 가능해진다.

아내의 학급이 연하장 카드를 디자인해서 생산한다고 생각해보자. 학생 한 명당 다섯 개씩 만들도록 할당하는 방법을 쓸 수 있을 것이다.  
이렇게 하는 것은 (상위의 수준에서 바라보았을 때) 카드를 만드는 한 가지 일만 일어나므로 병렬적이지만 동시적인 것은 아니다.

## 순차적 프로그래밍을 넘어서

병렬성과 동시성이 공유하는 속성은 작업이 한 번에 하나씩 순서대로 이루어지는 전통적인 순차적 프로그래밍 모델을 넘어선다는 데 있다.  
이 책에서 우리는 병렬성과 동시성을 함께 공부할 것이다.

동시성과 병렬성이 혼동되는 이유는 전통적으로 사용하는 스레드와 잠금장치는 병렬성을 직접 지원하지 않기 때문이다. 이러한 스레드와 잠금 장치를 이용하여 멀티코어를 활용하는 유일한 방법은 동시적인 프로그램을 작성해 병렬로 동작하는 하드웨어에서 실행하는 것이다.

하지만 이렇게 하는 것이 쉽지 않은 이유는 동시적인 프로그램은 기본적으로 비결정적이기 때문이다.

사건이 일어나는 시점, 즉 타이밍에 따라서 결과가 달라진다.

문제 자체가 본질적으로 동시적 프로그램을 작성하는 경우에는 비결정적인 동작을 자연스럽고 당연한 것으로 받아들인다. 반면 병렬성은 비결정성을 내포하지 않는다.

예컨대 배열에 담겨 있는 모든 숫자에 2를 곱하는 동작은, 배열의 절반은 한 코어에서 처리하고 나머지 절반은 다른 코어에서 처리한다는 이유만으로 결과가 달라지지 않는다 (적어도 그래선 안 된다).

명시적으로 병렬성을 지원하는 언어들은 비결정성이라는 유령을 두려워하지 않고 병렬 코드를 작성하는 방법을 제공한다.

## 일곱 가지 모델

동시성과 병렬성에 대한 거시적인 안목을 제공하기 위해서 이 책에서는 다음과 같은 일곱 가지의 모델을 선택했다.

### 1. 스레드와 잠금장치

스레드와 잠금장치는 문제점이 많지만 이 책에서 설명하는 다양한 모델의 배후에서 동작하는 기본 기술에 해당한다.  
많은 동시성 소프트웨어에서 여전히 기본적인 선택으로 활용되고 있다.

### 2. 함수형 프로그래밍

함수형 프로그래밍은 동시성과 병렬성을 잘 지원할 뿐만 아니라 여러 이유로도 사용이 확산되고 있다.  
가변 상태를 원천적으로 제거했기 때문에 함수형 프로그래밍은 기본적으로 스레드 - 안전을 보장하며 병렬처리가 쉽다.

### 3. 클로저 방식 - 아이덴티티와 상태 분리하기

클로저 언어는 명령형 프로그래밍과 함수형 프로그래밍을 효과적으로 결합하여 양쪽의 접근 방식이 지닌 장점을 극대화하고 널리 보급했다.

### 4. 액터

액터 모델은 광범위한 사용처를 가진 범용의 동시성 프로그래밍 모델이다.  
공유 메모리와 분산 메모리 아키텍처 양측에서 활용이 가능하고, 지리적 분산을 적극 지원하고, 장애 허용과 탄력성에 대한 지원이 특히 강하다.

### 5. 순차 프로세스 통신(CSP)

순차 프로세스 통신은 겉으로 보면 액터 모델과 공통점이 많다.  
둘 다 메시지를 전달하는 방식으로 동작하지만, CSP에서는 커뮤니케이션을 위해 액터 같은 개체가 아닌 채널이라는 개념이 사용되기 때문에, CSP를 사용하는 프로그램은 액터 모델과 전혀 다른 특징을 갖는다.

### 6. 데이터 병렬성

우리가 사용하는 노트북 내부에는 슈퍼컴퓨터가 숨어 있다. GPU는 주로 그래픽 처리를 위해서 데이터 병렬성을 활용하지만, 그러한 기능은 사실 여러 가지 다른 작업을 위해서 활용될 수 있다.  
유한 요서에 대한 분석을 수행하거나, 유체역학 계산을 수행하거나, 기타 엄청난 계산을 요구하는 코드를 작성하는 경우라면 GPU의 성능은 거의 다른 방법 전부를 능가할 것이다.

### 7. 람다 아키텍처

병렬성이 아니면 빅데이터 처리는 불가능하다. 여러 개의 컴퓨팅 자원을 활용할 수 있을때에 한해서 우리는 테라바이트에 달하는 데이터를 처리할 수 있다.  
람다 아키텍처는 맵리듀스와 스트리밍 프로세스의 장점을 결합해서 다양한 빅데이터 문제를 해결할 수 있도록 해준다.

### 그래서?

이러한 모델은 제각각 가장 알맞은 분야가 있다.

각 장을 읽으면서 다음의 질문들을 염두에 두기 바란다.

1. 이 모델은 동시성 문제, 병렬성 문제, 혹은 두 개를 모두 해결하는 데 적합한가?
2. 이 모델은 어떤 병렬 아키텍처를 타깃으로 삼고 있는가?
3. 이 모델은 탄력성을 갖춘 코드, 혹은 지리적으로 분산된 코드를 작성할 때 필요한 도구를 제공하는가?

다음 장에서 우리는 첫 번째 모델인 스레드와 잠금장치에 대해 살펴볼 것이다.
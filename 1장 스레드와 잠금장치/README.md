# 서문

최근 들어서 우리는 하나의 CPU 속도가 빨라지는 것이 아니라 컴퓨터에 들어가는 코어의 개수가 늘어나는 것을 알게 되었다.

허브 서터가 말한 것 처럼 "공짜 점심은 끝났다". 단순히 더 빠른 하드웨어가 출시되기를 기다리기만 하면 소프트웨어의 속도를 향상시킬 수 있던 시대는 지나갔다. 이제는 여러 개의 코어, 즉 병렬성을 활용해야 하는 것이다.

## 동시성 혹은 병렬성?

이 두 개념은 종종 비슷한 의미로 사용되지만, `동시적`이라는 말과 `병렬적`이라는 말은 서로 다른 개념이다.

`동시적` 프로그램은 여러 개의 논리적 `통제 흐름`을 갖는다. 이러한 논리적 흐름, 즉 스레드는 병렬로 실행될 수도 있고 그렇지 않을 수도 있다.

이에 비해서 `병렬적` 프로그램은 계산에 필요한 부분을 한꺼번에 (병렬로) 실행함으로써 순차적 프로그램보다 빨리 동작할 가능성이 있다. 프로그램에서 사용하는 논리적 통제 흐름은 하나가 될 수도 있고 그 이상일 수도 있다.

이러한 차이를 이해하는 또 다른 방식은 동시성이라는 문제 자체가 가진 속성에 있다고 생각한다는 점이다.

동시성 프로그램은 여러 사건을 한꺼번에 (혹은 거의 한꺼번에) 처리해야 하는 요구사항을 갖는다. 이에 비해서 병렬성은 문제가 아닌 해법이 가진 속성이므로, 프로그램 내의 각기 다른 부분을 병렬로 실행함으로써 해법 자체의 처리 속도를 더 빠르게 한다.

롭 파이크는 이렇게 말했다.

> 동시성은 여러 일을 한꺼번에 다루는 데 관한 것이다.  

> 병렬성은 여러 일을 한꺼번에 실행하는 데 관한 것이다.

그렇다면 이 책은 동시성에 대한 책인가, 아니면 병렬성에 대한 책인가?

### 예시

내 아내는 교사다. 다른 교사들과 마찬가지로 그녀는 멀티태스킹에 능숙하다.  
어느 한 시점에서 보면 그녀는 한 가지 일을 수행하지만, 언제나 여러 일을 한꺼번에 다루어야 한다.  
한 학생이 책을 읽는 것을 듣는 동시에, 떠들석한 교실을 진정시키거나 다른 학생의 질문에 답을 주는 식이다.  
이것이 동시성이지 병렬성은 아니다. 즉, 내 아내는 한 명 뿐이다.

그녀를 돕는 조교가 같이 있다면 (한 사람이 책 읽는 걸 듣고 지도하는 동안, 다른 사람은 질문에 답하는 식으로) 동시성과 병렬성이 모두 가능해진다.

아내의 학급이 연하장 카드를 디자인해서 생산한다고 생각해보자. 학생 한 명당 다섯 개씩 만들도록 할당하는 방법을 쓸 수 있을 것이다.  
이렇게 하는 것은 (상위의 수준에서 바라보았을 때) 카드를 만드는 한 가지 일만 일어나므로 병렬적이지만 동시적인 것은 아니다.

## 순차적 프로그래밍을 넘어서

병렬성과 동시성이 공유하는 속성은 작업이 한 번에 하나씩 순서대로 이루어지는 전통적인 순차적 프로그래밍 모델을 넘어선다는 데 있다.  
이 책에서 우리는 병렬성과 동시성을 함께 공부할 것이다.

동시성과 병렬성이 혼동되는 이유는 전통적으로 사용하는 스레드와 잠금장치는 병렬성을 직접 지원하지 않기 때문이다. 이러한 스레드와 잠금 장치를 이용하여 멀티코어를 활용하는 유일한 방법은 동시적인 프로그램을 작성해 병렬로 동작하는 하드웨어에서 실행하는 것이다.

하지만 이렇게 하는 것이 쉽지 않은 이유는 동시적인 프로그램은 기본적으로 비결정적이기 때문이다.

사건이 일어나는 시점, 즉 타이밍에 따라서 결과가 달라진다.

문제 자체가 본질적으로 동시적 프로그램을 작성하는 경우에는 비결정적인 동작을 자연스럽고 당연한 것으로 받아들인다. 반면 병렬성은 비결정성을 내포하지 않는다.

예컨대 배열에 담겨 있는 모든 숫자에 2를 곱하는 동작은, 배열의 절반은 한 코어에서 처리하고 나머지 절반은 다른 코어에서 처리한다는 이유만으로 결과가 달라지지 않는다 (적어도 그래선 안 된다).

명시적으로 병렬성을 지원하는 언어들은 비결정성이라는 유령을 두려워하지 않고 병렬 코드를 작성하는 방법을 제공한다.
# 1일 차: 상호배제와 메모리 모델

스레드와 잠금장치를 이용하는 프로그래밍은 마치 포드 모델 T와 비슷하다.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b3/Ford_Model_T_%28537880855%29.jpg" width=560 />

이 차로 A라는 장소에서 B라는 장소까지 운전해서 갈 수는 있지만 원시적이고 어려운 운전이 될 것이며, 새로운 기술과 비교하면 안정성도 떨어지고 위험하기까지 하다.

이미 알려진 수많은 문제점에도 불구하고 스레드와 잠금장치는 많은 동시성 소프트웨어를 작성할 때 기본 선택이 되고 있으며, 우리가 이 책에서 다루는 많은 다른 모델의 근간이 되기도 한다.  
이러한 기능을 직접 사용할 계획이 없더라도 그들이 어떻게 동작하는지는 이해하고 있어야 한다.

## 동작하는 가장 단순한 코드

스레드와 잠금장치는 실제 하드웨어가 동작하는 방식을 그대로 옮긴 것과 크게 다르지 않다.  
하드웨어와 비슷하다는 것은 엄청난 장점이기도, 엄청난 단점이기도 하다.  

이들은 너무 단순하기 때문에, 대부분의 언어가 어떠한 형태로든 이런 기능을 제공하고 있다.  
이런 기능을 사용할 때 따르는 제약이 거의 없기 때문에, 실력이 부족한 프로그래머를 보호해주는 기능도 없다.

따라서 이런 기능을 이용해서 정상 동작하는 코드를 작성하는 것 자체가 쉽지 않으며, 그런 코드를 유지보수하는 것은 더더욱 어렵다.

## 상호배제와 메모리 모델

동시성 프로그래밍을 조금이라도 해본 사람이라면 상호배제라는 개념을 알고 있을 것이다.  
잠금 장치를 사용하는 것은 특정한 데이터에 접근하는 스레드가 한 번에 하나만 존재하도록 강제한다.

경쟁 조건이나 데드락처럼 상호배제가 정상 동작하지 못하게 만드는 상태에 대해서도 알고 있을 것이다.

이런 상태는 실제로 심각한 문제기 때문에 자세히 설명할 것이다.

하지만 공유 메모리를 다룰때는 이런 것들보다 더 중요하고 근본적으로 고민해야 하는 문제가 있는데, 그게 바로 메모리 모델이다.  
경쟁 조건이나 데드락이 이상한 문제를 낳는 것처럼 보인다면 메모리 모델이라는 것은 얼마나 기괴한 문제를 낳는지 조금만 기다려보기 바란다.

## 첫 번째 잠금장치

여러 개의 함수가 공유된 메모리에 접근할 때에는 서로 동작이 엉킬 수도 있다.  
우리는 한 번에 하나의 함수만 실행하는 잠금장치를 사용함으로써 이러한 상황을 피할 수 있다.

Node.js의 Promise와 async/await을 공부하길 바란다.

## 여러 개의 잠금장치

모든 메서드를 동기화하는 것은 효율성이 극도로 떨어진다.  
대부분의 스레드는 아마도 대부분의 시간을 블로킹된 상태에서 보내게 될 것이다. (Node.js는 아예 멈춘다)  
그렇다면 스레드를 여럿 사용할 이유가 없어진다.

하지만 이는 그나마 나은 편이다. 일단 둘 이상의 스레드를 사용하기 시작하면 데드락이 발생할 가능성이 매우 높아진다.

동시성을 설명하는 학술 논문에서 흔히 사용되는 "식사하는 철학자"라는 예를 통해서 데드락을 보여주도록 하겠다.  
다음 그림에서 보는 것 처럼, 다섯 명의 철학자가 다섯 개의 젓가락이 준비되어 있는 동그란 식탁에 앉아 있다고 생각하자.

> ... 식사하는 철학자는 양이 너무 많아서 생략하겠습니다  
> Node.js에서 어떻게 이를 설명해야할지 모르겠네요

## 배운 내용

스레드를 만드는 방법과 모든 자바 객체에 내재되어 있는 잠금장치를 사용해서 스레드 사이의 상호배제를 강제하는 방법을 살펴보았다.  
그리고 스레드와 잠금장치를 이용할 때 만나게 되는 3가지 주요한 위험 요소인 경쟁 조건, 데드락, 그리고 메모리 가시성에 대해서 알아보았다.  
그리고 그들을 피하는 데 도움이 되는 규칙들도 살펴보았다.

1. 공유되는 변수에 대한 접근을 반드시 동기화한다.
2. 쓰는 스레드와 읽는 스레드가 모두 동기화되어야 한다.
3. 여러 개의 잠금장치를 미리 정해진 공통의 순서에 따라 요청한다.
4. 잠금장치를 가진 상태에서 외부 메서드를 호출하지 않는다.
5. 잠금장치는 최대한 짧게 보유한다.

### 경쟁 조건, 데드락, 메모리 가시성이란

1. 경쟁 조건: 다중 프로세스 환경에서 두개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태를 뜻한다.
2. 데드락: 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 뜻한다. 이는 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.  
3. 메모리 가시성: 한 스레드에서 변경한 특정 메모리 값이 다른 스레드에서 제대로 읽어지는지를 뜻한다.

# 2일 차: 내재된 잠금장치를 넘어서

내재된 잠금장치는 편리하지만 다음과 같은 한계를 갖는다.

1. 내재된 잠금장치를 얻으려고 하다가 블로킹 상태에 빠진 스레드를 원상복귀시킬 방법이 없다.  
2. 내재된 잠금장치를 얻으려고 노력하는 시간을 강제로 중단시키는 타임아웃 기능이 없다.  
3. 내재된 잠금장치를 얻는 방법이 하나만 존재한다. synchronized 블록을 사용하는 것이 그것이다.

> ... Java의 ReentrantLock에 대한 설명

## 배운 내용

1. 잠금장치를 얻고자 기다리는 과정을 가로챌 수 있다.
2. 잠금장치를 기다리는 동안 타임아웃이 발생할 수 있다.
3. 잠금장치를 얻고 반납하는 동작이 임의의 순서로 일어날 수 있다.
4. 임의의 조건이 참이 되는 것을 기다리기 위해 조건 변수를 사용할 수 있다.
5. 원자 변수를 이용해서 잠금장치를 사용하는 것을 피할 수 있다.

> Java에 대한 내용이어서 Node.js에서는 어떻게 설명해야할지 모르겠네요

### 자율학습

#### 불필요한 기상

스레드 시그널링의 목적은 쓰레드들이 서로 신호를 교환하도록 하기 위함이다. 스레드 시그널링은 스레드에게 다른 스레드로부터의 신호를 기다리도록 할 수 있다. 예를 들어, Thread B 는 Thread A 의 신호 -처리될 데이터가 준비되었다는- 가 올 때 까지 대기할 수 있다.

1. 무엇인가?

> 알 수 없는 이유로, notify() 나 notifyAll() 이 호출되지 않았음에도 불구하고 스레드가 깨어나는 현상이다. 어떤 분명한 이유없이 스레드가 깨어난다.

2. 언제 이런 일이 일어나는가?

> 조사해봤는데, 이유 없이 갑자기 일어난다고 한다. 조사를 잘못한 것 같다.  
> 그렇지만, 구글에 어떻게 검색해야 해당 자료가 나오는지를 전혀 모르겠다.

3. 좋은 코드에서는 이런 일이 일어나지 않아야 하는 이유는 무엇인가?

> 전혀 예상 못한 논리적 통제 흐름이 새롭게 생기는 것이기 때문이다.  
> 이로 인해 데드락, 메모리 가시성 문제가 발생할 가능성이 매우 높다고 생각한다.

# 3일 차: 거인의 어깨 위에서

> ... Java 기능들이 나와서 생략. Node.js에서는 Promise.all + Array.map로 해결되는 문제  
> 생산자와 소비자 패턴도 나왔다 (여기서 포이즌 필도 나왔다)

## 배운 내용

1. 스레드를 직접 만드는 대신 스레드 풀을 이용한다.
2. 생산자와 소비자가 ArrayBlockingQueue를 이용해 더 효과적으로 의사소통을 한다.
3. CopyOnWriteArrayList를 이용해 리스너 관리를 더 쉽고 효과적으로 만든다.
4. ConcurrentHashMap을 이용해 맵에 대한 동시적인 접근을 지원한다.

### 자율학습

#### 암달의 법칙

1. 무엇인가?

> 컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는데 사용된다.  
>  
> 병렬 컴퓨팅에서 멀티 프로세서를 사용할 때 프로그램의 성능향상은 프로그램의 순차적인 부분에 의해 제한된다.    
> 예를 들면, 프로그램의 95%가 병렬화 할 수 있다면 이론적인 최대 성능 향상은 아무리 많은 프로세서를 사용하더라도 최대 20배로 제한된다.

![암달의 법칙 예시](https://upload.wikimedia.org/wikipedia/commons/e/ea/AmdahlsLaw.svg)

# 마치며

스레드와 잠금장치를 이용한 프로그래밍은 아마 이 책에서 보게 될 그 어떤 테크닉보다 사람들의 의견을 확연하게 둘로 나누는 것처럼 보인다.  
어떤 사람들은 이것이 올바르게 사용하는 것이 너무나 어렵게 느껴지기 때문에, 아예 사용하는 것을 회피하고 멀티스레드 코드를 작성하는 것 자체를 원치 않는다.  

> 그래서 Node.js가 태어나게 된 걸까? [참고](https://ichi.pro/ko/jabawa-node-jsui-meolti-seuleding-216985330798793)

어떤 사람들은 그런 호들갑을 이해하지 못한다. 몇 개의 간단한 규칙만 지켜지면 충분하고, 그렇게 하는 것이야말로 다른 어떤 형태의 프로그래밍과 다를 바 없다고 여긴다.

이러한 방법이 갖는 장점과 단점을 살펴보도록 하자.

## 장점

스레드와 잠금장치가 갖는 최고의 장점은 이 모델의 폭넓은 적용범위다.  
이 책에서 살펴보는 다른 방법들이 대부분 이 모델에 기초를 두고 있다는 사실에서 유추할 수 있듯이, 스레드와 잠금장치는 매우 광범위한 문제에 적용될 수 있다.  
그들은 (하드웨어가 수행하는 동작을 약간의 공식으로 포착한 것에 불과하다는 점에서) "기계 자체에 가깝기" 때문에 정확하게 사용되면 매우 효율적일 수 있다.  
이것은 이들이 미세한 것에서부터 굵직굵직한 것에 이르기까지 다양한 범위의 문제를 해결하는 데 사용될 수 있음을 뜻한다.

또한 이러한 모델은 대부분의 프로그래밍 언어에 쉽게 통합될 수 있다. 언어를 설계하는 사람들은 스레드와 잠금장치를 이미 존재하는 명령형 혹은 객체 지향 언어에 별 어려움 없이 덧붙일 수 있다.

## 단점

스레드와 잠금장치는 병렬성을 지원하지 않는다. (앞에서 동시성과 병렬성이 같은 것이 아니라고 말했던 것을 기억하는가?)  
단어 세기 예에서 보았던 것처럼 그들은 순차적 알고리즘을 병렬화하는 데 사용할 수 있다. 하지만 이렇게 하는 것은 비결정성이라는 요괴를 낳는 동시에 원시적인 구조물을 사용하는 것이 필요하다.

몇몇 실험적인 분산 공유 메모리 연구 시스템을 제외하면 스레드와 잠금장치는 공유 메모리 아키텍처만 지원한다. (지역적이거나 혹은 탄력성 제공을 위한)  
분산 메모리를 지원할 필요가 있으면 다른 방법을 찾아야 한다.  

> Node.js는 스레드간 공유 메모리가 없다!  
> 심지어 스레드도 Node.js 10 버전에 들어서부터 만들 수 있게 되었다.

이것은 곧 스레드와 잠금장치는 크기가 너무 커서 단일 시스템 메모리에 완전히 올라올 수 없는 문제를 해결하기에는 적합하지 않음을 의미한다.  

이 방법이 갖는 가장 커다란 단점은 스레드와 잠금장치를 이용하는 것이 무엇보다 어렵다는 점이다.  
언어를 설계하는 사람은 이런 기능을 추가하는 것이 쉬울지 몰라도, 불쌍한 우리 프로그래머들에게는 별로 도움이 되지 않는다.

### 방 안의 코끼리



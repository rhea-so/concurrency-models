# 1일 차: 상호배제와 메모리 모델

스레드와 잠금장치를 이용하는 프로그래밍은 마치 포드 모델 T와 비슷하다.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b3/Ford_Model_T_%28537880855%29.jpg" width=560 />

이 차로 A라는 장소에서 B라는 장소까지 운전해서 갈 수는 있지만 원시적이고 어려운 운전이 될 것이며, 새로운 기술과 비교하면 안정성도 떨어지고 위험하기까지 하다.

이미 알려진 수많은 문제점에도 불구하고 스레드와 잠금장치는 많은 동시성 소프트웨어를 작성할 때 기본 선택이 되고 있으며, 우리가 이 책에서 다루는 많은 다른 모델의 근간이 되기도 한다.  
이러한 기능을 직접 사용할 계획이 없더라도 그들이 어떻게 동작하는지는 이해하고 있어야 한다.

## 동작하는 가장 단순한 코드

스레드와 잠금장치는 실제 하드웨어가 동작하는 방식을 그대로 옮긴 것과 크게 다르지 않다.  
하드웨어와 비슷하다는 것은 엄청난 장점이기도, 엄청난 단점이기도 하다.  

이들은 너무 단순하기 때문에, 대부분의 언어가 어떠한 형태로든 이런 기능을 제공하고 있다.  
이런 기능을 사용할 때 따르는 제약이 거의 없기 때문에, 실력이 부족한 프로그래머를 보호해주는 기능도 없다.

따라서 이런 기능을 이용해서 정상 동작하는 코드를 작성하는 것 자체가 쉽지 않으며, 그런 코드를 유지보수하는 것은 더더욱 어렵다.

## 상호배제와 메모리 모델

동시성 프로그래밍을 조금이라도 해본 사람이라면 상호배제라는 개념을 알고 있을 것이다.  
잠금 장치를 사용하는 것은 특정한 데이터에 접근하는 스레드가 한 번에 하나만 존재하도록 강제한다.

경쟁 조건이나 데드락처럼 상호배제가 정상 동작하지 못하게 만드는 상태에 대해서도 알고 있을 것이다.

이런 상태는 실제로 심각한 문제기 때문에 자세히 설명할 것이다.

하지만 공유 메모리를 다룰때는 이런 것들보다 더 중요하고 근본적으로 고민해야 하는 문제가 있는데, 그게 바로 메모리 모델이다.  
경쟁 조건이나 데드락이 이상한 문제를 낳는 것처럼 보인다면 메모리 모델이라는 것은 얼마나 기괴한 문제를 낳는지 조금만 기다려보기 바란다.

## 첫 번째 잠금장치

여러 개의 함수가 공유된 메모리에 접근할 때에는 서로 동작이 엉킬 수도 있다.  
우리는 한 번에 하나의 함수만 실행하는 잠금장치를 사용함으로써 이러한 상황을 피할 수 있다.

Node.js의 Promise와 async/await을 공부하길 바란다.

## 여러 개의 잠금장치

모든 메서드를 동기화하는 것은 효율성이 극도로 떨어진다.  
대부분의 스레드는 아마도 대부분의 시간을 블로킹된 상태에서 보내게 될 것이다. (Node.js는 아예 멈춘다)  
그렇다면 스레드를 여럿 사용할 이유가 없어진다.

하지만 이는 그나마 나은 편이다. 일단 둘 이상의 스레드를 사용하기 시작하면 데드락이 발생할 가능성이 매우 높아진다.

동시성을 설명하는 학술 논문에서 흔히 사용되는 "식사하는 철학자"라는 예를 통해서 데드락을 보여주도록 하겠다.  
다음 그림에서 보는 것 처럼, 다섯 명의 철학자가 다섯 개의 젓가락이 준비되어 있는 동그란 식탁에 앉아 있다고 생각하자.

> ... 식사하는 철학자는 양이 너무 많아서 생략하겠습니다  
> Node.js에서 어떻게 이를 설명해야할지 모르겠네요

## 배운 내용

스레드를 만드는 방법과 모든 자바 객체에 내재되어 있는 잠금장치를 사용해서 스레드 사이의 상호배제를 강제하는 방법을 살펴보았다.  
그리고 스레드와 잠금장치를 이용할 때 만나게 되는 3가지 주요한 위험 요소인 경쟁 조건, 데드락, 그리고 메모리 가시성에 대해서 알아보았다.  
그리고 그들을 피하는 데 도움이 되는 규칙들도 살펴보았다.

1. 공유되는 변수에 대한 접근을 반드시 동기화한다.
2. 쓰는 스레드와 읽는 스레드가 모두 동기화되어야 한다.
3. 여러 개의 잠금장치를 미리 정해진 공통의 순서에 따라 요청한다.
4. 잠금장치를 가진 상태에서 외부 메서드를 호출하지 않는다.
5. 잠금장치는 최대한 짧게 보유한다.

### 경쟁 조건, 데드락, 메모리 가시성이란

1. 경쟁 조건: 다중 프로세스 환경에서 두개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태를 뜻한다.
2. 데드락: 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 뜻한다. 이는 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.  
3. 메모리 가시성: 한 스레드에서 변경한 특정 메모리 값이 다른 스레드에서 제대로 읽어지는지를 뜻한다.

# 2일 차: 내재된 잠금장치를 넘어서

내재된 잠금장치는 편리하지만 다음과 같은 한계를 갖는다.

1. 내재된 잠금장치를 얻으려고 하다가 블로킹 상태에 빠진 스레드를 원상복귀시킬 방법이 없다.  
2. 내재된 잠금장치를 얻으려고 노력하는 시간을 강제로 중단시키는 타임아웃 기능이 없다.  
3. 내재된 잠금장치를 얻는 방법이 하나만 존재한다. synchronized 블록을 사용하는 것이 그것이다.

> ... Java의 ReentrantLock에 대한 설명

## 배운 내용

1. 잠금장치를 얻고자 기다리는 과정을 가로챌 수 있다.
2. 잠금장치를 기다리는 동안 타임아웃이 발생할 수 있다.
3. 잠금장치를 얻고 반납하는 동작이 임의의 순서로 일어날 수 있다.
4. 임의의 조건이 참이 되는 것을 기다리기 위해 조건 변수를 사용할 수 있다.
5. 원자 변수를 이용해서 잠금장치를 사용하는 것을 피할 수 있다.

> Java에 대한 내용이어서 Node.js에서는 어떻게 설명해야할지 모르겠네요

### 자율학습

#### 불필요한 기상

스레드 시그널링의 목적은 쓰레드들이 서로 신호를 교환하도록 하기 위함이다. 스레드 시그널링은 스레드에게 다른 스레드로부터의 신호를 기다리도록 할 수 있다. 예를 들어, Thread B 는 Thread A 의 신호 -처리될 데이터가 준비되었다는- 가 올 때 까지 대기할 수 있다.

1. 무엇인가?

> 알 수 없는 이유로, notify() 나 notifyAll() 이 호출되지 않았음에도 불구하고 스레드가 깨어나는 현상이다. 어떤 분명한 이유없이 스레드가 깨어난다.

2. 언제 이런 일이 일어나는가?

> 조사해봤는데, 이유 없이 갑자기 일어난다고 한다. 조사를 잘못한 것 같다.  
> 그렇지만, 구글에 어떻게 검색해야 해당 자료가 나오는지를 전혀 모르겠다.

3. 좋은 코드에서는 이런 일이 일어나지 않아야 하는 이유는 무엇인가?

> 전혀 예상 못한 논리적 통제 흐름이 새롭게 생기는 것이기 때문이다.  
> 이로 인해 데드락, 메모리 가시성 문제가 발생할 가능성이 매우 높다고 생각한다.

# 3일 차: 거인의 어깨 위에서





